name: Deploy Catalog Server

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: eu-west-1
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.10'

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    outputs:
      ec2_public_ip: ${{ steps.terraform.outputs.ec2_public_ip }}
      cognito_user_pool_id: ${{ steps.terraform.outputs.cognito_user_pool_id }}
      cognito_user_pool_client_id: ${{ steps.terraform.outputs.cognito_user_pool_client_id }}
      cognito_identity_pool_id: ${{ steps.terraform.outputs.cognito_identity_pool_id }}
      rds_endpoint: ${{ steps.terraform.outputs.rds_endpoint }}
      infrastructure_changed: ${{ steps.terraform.outputs.infrastructure_changed }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: Create Terraform variables file
      run: |
        cd terraform
        cat > terraform.tfvars << EOF
        aws_region = "${{ env.AWS_REGION }}"
        project_name = "catalog-server"
        environment = "production"
        instance_type = "t3.micro"
        key_pair_name = "catalog-server-key"
        allowed_cidr_blocks = ["0.0.0.0/0"]
        db_username = "catalog_user"
        db_password = "${{ secrets.DB_PASSWORD }}"
        db_name = "catalogdb"
        EOF

    - name: Terraform Init
      run: |
        cd terraform
        terraform init

    - name: Check Existing Infrastructure
      id: check_infra
      run: |
        cd terraform
        # Check if state exists and get current outputs
        if terraform state list > /dev/null 2>&1; then
          echo "=== Existing Infrastructure Found ==="
          echo "Current resources in state:"
          terraform state list
          
          echo "=== Current Outputs ==="
          terraform output || echo "No outputs available yet"
          
          # Try to get existing EC2 IP
          EXISTING_EC2_IP=$(terraform output -raw ec2_public_ip 2>/dev/null || echo "")
          if [ -n "$EXISTING_EC2_IP" ] && [ "$EXISTING_EC2_IP" != "" ]; then
            echo "Found existing EC2 instance with IP: $EXISTING_EC2_IP"
            echo "existing_ec2_ip=$EXISTING_EC2_IP" >> $GITHUB_OUTPUT
          fi
        else
          echo "No existing infrastructure found"
        fi

    - name: Terraform Plan
      id: plan
      run: |
        cd terraform
        terraform plan -detailed-exitcode -out=tfplan
        PLAN_EXIT_CODE=$?
        
        echo "Terraform plan exit code: $PLAN_EXIT_CODE"
        
        if [ $PLAN_EXIT_CODE -eq 0 ]; then
          echo "No changes needed"
          echo "changes_needed=false" >> $GITHUB_OUTPUT
        elif [ $PLAN_EXIT_CODE -eq 2 ]; then
          echo "Changes detected"
          echo "changes_needed=true" >> $GITHUB_OUTPUT
          
          # Show what will change
          echo "=== Planned Changes ==="
          terraform show tfplan
        else
          echo "Plan failed"
          exit 1
        fi

    - name: Terraform Apply
      id: terraform
      run: |
        cd terraform
        
        # Apply the plan (will be no-op if no changes needed)
        terraform apply -auto-approve tfplan
        
        # Get all outputs
        echo "=== Infrastructure Outputs ==="
        terraform output
        
        # Capture outputs for other jobs
        EC2_IP=$(terraform output -raw ec2_public_ip)
        COGNITO_USER_POOL_ID=$(terraform output -raw cognito_user_pool_id)
        COGNITO_CLIENT_ID=$(terraform output -raw cognito_user_pool_client_id)
        COGNITO_IDENTITY_POOL_ID=$(terraform output -raw cognito_identity_pool_id)
        RDS_ENDPOINT=$(terraform output -raw rds_endpoint)
        
        echo "EC2 Public IP: $EC2_IP"
        echo "RDS Endpoint: $RDS_ENDPOINT"
        
        # Set outputs for other jobs
        echo "ec2_public_ip=$EC2_IP" >> $GITHUB_OUTPUT
        echo "cognito_user_pool_id=$COGNITO_USER_POOL_ID" >> $GITHUB_OUTPUT
        echo "cognito_user_pool_client_id=$COGNITO_CLIENT_ID" >> $GITHUB_OUTPUT
        echo "cognito_identity_pool_id=$COGNITO_IDENTITY_POOL_ID" >> $GITHUB_OUTPUT
        echo "rds_endpoint=$RDS_ENDPOINT" >> $GITHUB_OUTPUT
        echo "infrastructure_changed=${{ steps.plan.outputs.changes_needed }}" >> $GITHUB_OUTPUT

  test-backend:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install Python dependencies
      run: |
        cd backend
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Test backend
      env:
        DATABASE_URL: postgresql://postgres:testpass@localhost:5432/testdb
        SECRET_KEY: test-secret-key
      run: |
        cd backend
        python -c "
        from app import app, db
        with app.app_context():
            db.create_all()
            print('Backend tests passed!')
        "

  build-frontend:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install frontend dependencies
      run: |
        cd frontend
        npm ci

    - name: Generate environment file
      run: |
        cd frontend
        cat > .env << EOF
        REACT_APP_USER_POOL_ID=${{ needs.deploy-infrastructure.outputs.cognito_user_pool_id }}
        REACT_APP_USER_POOL_CLIENT_ID=${{ needs.deploy-infrastructure.outputs.cognito_user_pool_client_id }}
        REACT_APP_IDENTITY_POOL_ID=${{ needs.deploy-infrastructure.outputs.cognito_identity_pool_id }}
        REACT_APP_API_URL=http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
        REACT_APP_AWS_REGION=${{ env.AWS_REGION }}
        EOF

    - name: Build frontend
      run: |
        cd frontend
        npm run build

    - name: Upload frontend build
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: frontend/build/

  deploy-application:
    needs: [deploy-infrastructure, test-backend, build-frontend]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download frontend build
      uses: actions/download-artifact@v4
      with:
        name: frontend-build
        path: frontend/build/

    - name: Generate backend environment file
      run: |
        cd backend
        cat > .env << EOF
        DATABASE_URL=postgresql://catalog_user:${{ secrets.DB_PASSWORD }}@${{ needs.deploy-infrastructure.outputs.rds_endpoint }}:5432/catalogdb
        SECRET_KEY=${{ secrets.FLASK_SECRET_KEY }}
        FLASK_ENV=production
        EOF

    - name: Deploy to EC2
      env:
        EC2_HOST: ${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
        EC2_USER: ubuntu
        EC2_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
        INFRASTRUCTURE_CHANGED: ${{ needs.deploy-infrastructure.outputs.infrastructure_changed }}
      run: |
        # Validate we have an EC2 host
        if [ -z "$EC2_HOST" ] || [ "$EC2_HOST" = "null" ]; then
          echo "ERROR: No EC2 host available"
          echo "Infrastructure changed: $INFRASTRUCTURE_CHANGED"
          exit 1
        fi
        
        echo "Deploying to existing EC2 instance: $EC2_HOST"
        echo "Infrastructure changed: $INFRASTRUCTURE_CHANGED"
        
        echo "$EC2_KEY" > ec2-key.pem
        chmod 600 ec2-key.pem
        
        # Test SSH connectivity
        echo "Testing SSH connection..."
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 $EC2_USER@$EC2_HOST "echo 'SSH connection successful'"
        
        # Only wait for cloud-init if infrastructure changed
        if [ "$INFRASTRUCTURE_CHANGED" = "true" ]; then
          echo "Infrastructure changed, waiting for cloud-init..."
          ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "sudo cloud-init status --wait" || echo "Cloud-init check completed"
        else
          echo "Using existing infrastructure, skipping cloud-init wait"
        fi
        
        echo "Ensuring directory structure..."
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          sudo mkdir -p /opt/catalog-server/backend /opt/catalog-server/frontend
          sudo chown -R catalog:catalog /opt/catalog-server
          sudo chmod -R 755 /opt/catalog-server
        "
        
        # Deploy nginx config if it exists
        if [ -f nginx/catalog.conf ]; then
          echo "Deploying nginx config..."
          scp -i ec2-key.pem -o StrictHostKeyChecking=no nginx/catalog.conf $EC2_USER@$EC2_HOST:/tmp/
        fi
        
        echo "Deploying backend files..."
        scp -i ec2-key.pem -o StrictHostKeyChecking=no -r backend/* $EC2_USER@$EC2_HOST:/tmp/backend-files/
        
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          # Stop existing service
          sudo systemctl stop catalog || true
          
          # Update backend files
          sudo cp -r /tmp/backend-files/* /opt/catalog-server/backend/
          sudo chown -R catalog:catalog /opt/catalog-server/backend
          sudo rm -rf /tmp/backend-files
          
          # Ensure dependencies are installed
          cd /opt/catalog-server/backend
          source venv/bin/activate
          pip install --no-deps Flask-SQLAlchemy Flask-CORS python-dotenv || true
        "
        
        echo "Deploying frontend files..."
        scp -i ec2-key.pem -o StrictHostKeyChecking=no -r frontend/build/* $EC2_USER@$EC2_HOST:/tmp/frontend-files/
        
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          sudo cp -r /tmp/frontend-files/* /opt/catalog-server/frontend/
          sudo chown -R catalog:catalog /opt/catalog-server/frontend
          sudo rm -rf /tmp/frontend-files
        "
        
        echo "Configuring services..."
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          # Update nginx config if provided
          if [ -f /tmp/catalog.conf ]; then
            sudo cp /tmp/catalog.conf /etc/nginx/sites-available/catalog
            sudo ln -sf /etc/nginx/sites-available/catalog /etc/nginx/sites-enabled/
            sudo rm -f /etc/nginx/sites-enabled/default
            sudo nginx -t && echo 'Nginx config valid' || echo 'Nginx config invalid, using default'
          fi
          
          # Ensure systemd service exists and is correct
          sudo systemctl daemon-reload
          sudo systemctl enable catalog
          sudo systemctl start catalog
          sudo systemctl restart nginx
          
          # Show service status
          echo '=== Service Status ==='
          sudo systemctl status catalog --no-pager || true
          sudo systemctl status nginx --no-pager || true
        "

    - name: Health check
      env:
        API_URL: http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
        EC2_HOST: ${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
        EC2_USER: ubuntu
        EC2_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
      run: |
        echo "$EC2_KEY" > ec2-key.pem
        chmod 600 ec2-key.pem
        
        echo "Waiting for services to start..."
        sleep 30
        
        echo "=== Service Health Check ==="
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          sudo systemctl is-active catalog && echo 'Catalog service: ACTIVE' || echo 'Catalog service: INACTIVE'
          sudo systemctl is-active nginx && echo 'Nginx service: ACTIVE' || echo 'Nginx service: INACTIVE'
          curl -f http://localhost:5000/health && echo 'Local health check: PASSED' || echo 'Local health check: FAILED'
          sudo ss -tlnp | grep :5000 && echo 'Port 5000: LISTENING' || echo 'Port 5000: NOT LISTENING'
        "
        
        echo "=== External Health Check ==="
        if curl -f $API_URL/health; then
          echo "✅ Health check PASSED"
          curl -f $API_URL/products && echo "✅ Products endpoint PASSED" || echo "❌ Products endpoint FAILED"
        else
          echo "❌ Health check FAILED"
          ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
            echo '=== Debug Info ==='
            sudo journalctl -u catalog --no-pager -n 20
            sudo tail -10 /var/log/nginx/error.log || echo 'No nginx error logs'
          "
          exit 1
        fi
        
        echo "✅ Deployment successful!"
        echo "🌐 Application URL: $API_URL"
        
        rm ec2-key.pem

    - name: Deployment summary
      run: |
        echo "## 🚀 Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status | URL |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|-----|" >> $GITHUB_STEP_SUMMARY
        echo "| Infrastructure | ✅ ${{ needs.deploy-infrastructure.outputs.infrastructure_changed == 'true' && 'Updated' || 'Existing' }} | - |" >> $GITHUB_STEP_SUMMARY
        echo "| Application | ✅ Deployed | http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }} |" >> $GITHUB_STEP_SUMMARY
        echo "| API Health | ✅ Healthy | http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}/health |" >> $GITHUB_STEP_SUMMARY