name: Deploy Catalog Server

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: eu-west-1
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.10'

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    outputs:
      ec2_public_ip: ${{ steps.terraform.outputs.ec2_public_ip }}
      cognito_user_pool_id: ${{ steps.terraform.outputs.cognito_user_pool_id }}
      cognito_user_pool_client_id: ${{ steps.terraform.outputs.cognito_user_pool_client_id }}
      cognito_identity_pool_id: ${{ steps.terraform.outputs.cognito_identity_pool_id }}
      rds_endpoint: ${{ steps.terraform.outputs.rds_endpoint }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: Create Terraform variables file
      run: |
        cd terraform
        cat > terraform.tfvars << EOF
        aws_region = "${{ env.AWS_REGION }}"
        project_name = "catalog-server"
        environment = "production"
        instance_type = "t3.micro"
        key_pair_name = "catalog-server-key"
        allowed_cidr_blocks = ["0.0.0.0/0"]
        db_username = "catalog_user"
        db_password = "${{ secrets.DB_PASSWORD }}"
        db_name = "catalogdb"
        EOF

    - name: Terraform Init
      run: |
        cd terraform
        terraform init

    - name: Terraform Plan
      run: |
        cd terraform
        terraform plan

    - name: Terraform Apply
      id: terraform
      run: |
        cd terraform
        terraform apply -auto-approve
        echo "ec2_public_ip=$(terraform output -raw ec2_public_ip)" >> $GITHUB_OUTPUT
        echo "cognito_user_pool_id=$(terraform output -raw cognito_user_pool_id)" >> $GITHUB_OUTPUT
        echo "cognito_user_pool_client_id=$(terraform output -raw cognito_user_pool_client_id)" >> $GITHUB_OUTPUT
        echo "cognito_identity_pool_id=$(terraform output -raw cognito_identity_pool_id)" >> $GITHUB_OUTPUT
        echo "rds_endpoint=$(terraform output -raw rds_endpoint)" >> $GITHUB_OUTPUT

  test-backend:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install Python dependencies
      run: |
        cd backend
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Test backend
      env:
        DATABASE_URL: postgresql://postgres:testpass@localhost:5432/testdb
        SECRET_KEY: test-secret-key
      run: |
        cd backend
        python -c "
        from app import app, db
        with app.app_context():
            db.create_all()
            print('Backend tests passed!')
        "

  build-frontend:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install frontend dependencies
      run: |
        cd frontend
        npm ci

    - name: Generate environment file
      run: |
        cd frontend
        cat > .env << EOF
        REACT_APP_USER_POOL_ID=${{ needs.deploy-infrastructure.outputs.cognito_user_pool_id }}
        REACT_APP_USER_POOL_CLIENT_ID=${{ needs.deploy-infrastructure.outputs.cognito_user_pool_client_id }}
        REACT_APP_IDENTITY_POOL_ID=${{ needs.deploy-infrastructure.outputs.cognito_identity_pool_id }}
        REACT_APP_API_URL=http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
        REACT_APP_AWS_REGION=${{ env.AWS_REGION }}
        EOF

    - name: Build frontend
      run: |
        cd frontend
        npm run build

    - name: Upload frontend build
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: frontend/build/

  deploy-application:
    needs: [deploy-infrastructure, test-backend, build-frontend]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download frontend build
      uses: actions/download-artifact@v4
      with:
        name: frontend-build
        path: frontend/build/

    - name: Generate backend environment file
      run: |
        cd backend
        cat > .env << EOF
        DATABASE_URL=postgresql://catalog_user:${{ secrets.DB_PASSWORD }}@${{ needs.deploy-infrastructure.outputs.rds_endpoint }}:5432/catalogdb
        SECRET_KEY=${{ secrets.FLASK_SECRET_KEY }}
        FLASK_ENV=production
        EOF

    - name: Deploy to EC2
      env:
        EC2_HOST: ${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
        EC2_USER: ubuntu
        EC2_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
      run: |
        echo "$EC2_KEY" > ec2-key.pem
        chmod 600 ec2-key.pem
        
        echo "Waiting for EC2 instance..."
        sleep 120
        
        echo "Checking cloud-init status..."
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "sudo cloud-init status --wait"
        
        echo "Setting up directories..."
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          sudo mkdir -p /opt/catalog-server/backend /opt/catalog-server/frontend
          sudo chown -R catalog:catalog /opt/catalog-server
          sudo chmod -R 755 /opt/catalog-server
        "
        
        if [ -f nginx/catalog.conf ]; then
          echo "Deploying nginx config..."
          scp -i ec2-key.pem -o StrictHostKeyChecking=no nginx/catalog.conf $EC2_USER@$EC2_HOST:/tmp/
        fi
        
        echo "Deploying backend files..."
        scp -i ec2-key.pem -o StrictHostKeyChecking=no -r backend/* $EC2_USER@$EC2_HOST:/tmp/backend-files/
        
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          sudo systemctl stop catalog || true
          sudo cp -r /tmp/backend-files/* /opt/catalog-server/backend/
          sudo chown -R catalog:catalog /opt/catalog-server/backend
          sudo rm -rf /tmp/backend-files
          
          cd /opt/catalog-server/backend
          source venv/bin/activate
          pip install --no-deps Flask-SQLAlchemy Flask-CORS python-dotenv || true
        "
        
        echo "Deploying frontend files..."
        scp -i ec2-key.pem -o StrictHostKeyChecking=no -r frontend/build/* $EC2_USER@$EC2_HOST:/tmp/frontend-files/
        
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          sudo cp -r /tmp/frontend-files/* /opt/catalog-server/frontend/
          sudo chown -R catalog:catalog /opt/catalog-server/frontend
          sudo rm -rf /tmp/frontend-files
        "
        
        echo "Configuring services..."
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          if [ -f /tmp/catalog.conf ]; then
            sudo cp /tmp/catalog.conf /etc/nginx/sites-available/catalog
            sudo ln -sf /etc/nginx/sites-available/catalog /etc/nginx/sites-enabled/
            sudo rm -f /etc/nginx/sites-enabled/default
          fi
          
          sudo nginx -t || echo 'Nginx config test failed'
        "
        
        # Create systemd service
        cat > catalog.service << 'EOF'
        [Unit]
        Description=Catalog Server Flask Application
        After=network.target
        
        [Service]
        Type=simple
        User=catalog
        Group=catalog
        WorkingDirectory=/opt/catalog-server/backend
        Environment=PATH=/opt/catalog-server/backend/venv/bin
        ExecStart=/opt/catalog-server/backend/venv/bin/python app.py
        Restart=always
        RestartSec=3
        
        [Install]
        WantedBy=multi-user.target
        EOF
        
        scp -i ec2-key.pem -o StrictHostKeyChecking=no catalog.service $EC2_USER@$EC2_HOST:/tmp/
        
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          sudo cp /tmp/catalog.service /etc/systemd/system/
          sudo systemctl daemon-reload
          sudo systemctl enable catalog
          sudo systemctl start catalog
          sudo systemctl restart nginx
        "
        
        rm catalog.service

    - name: Health check
      env:
        API_URL: http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
        EC2_HOST: ${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
        EC2_USER: ubuntu
        EC2_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
      run: |
        echo "$EC2_KEY" > ec2-key.pem
        chmod 600 ec2-key.pem
        
        echo "Waiting for services..."
        sleep 30
        
        echo "=== Service Status ==="
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          sudo systemctl status catalog --no-pager || true
          sudo systemctl status nginx --no-pager || true
          curl -f http://localhost:5000/health || echo 'Local health check failed'
          sudo ss -tlnp | grep :5000 || echo 'Port 5000 not listening'
        "
        
        echo "=== External Health Check ==="
        if curl -f $API_URL/health; then
          echo "Health check passed"
        else
          echo "Health check failed"
          ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
            sudo journalctl -u catalog --no-pager -n 20
          "
          exit 1
        fi
        
        curl -f $API_URL/products || exit 1
        
        echo "✅ Deployment successful!"
        echo "🌐 Application URL: $API_URL"
        
        rm ec2-key.pem

    - name: Deployment summary
      run: |
        echo "## 🚀 Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status | URL |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|-----|" >> $GITHUB_STEP_SUMMARY
        echo "| Application | ✅ Deployed | http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }} |" >> $GITHUB_STEP_SUMMARY
        echo "| API Health | ✅ Healthy | http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}/health |" >> $GITHUB_STEP_SUMMARY