name: Deploy Catalog Server

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: eu-west-1
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.10'

jobs:
  # Infrastructure deployment
  deploy-infrastructure:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    outputs:
      ec2_public_ip: ${{ steps.terraform.outputs.ec2_public_ip }}
      cognito_user_pool_id: ${{ steps.terraform.outputs.cognito_user_pool_id }}
      cognito_user_pool_client_id: ${{ steps.terraform.outputs.cognito_user_pool_client_id }}
      cognito_identity_pool_id: ${{ steps.terraform.outputs.cognito_identity_pool_id }}
      rds_endpoint: ${{ steps.terraform.outputs.rds_endpoint }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: Create Terraform variables file
      run: |
        cd terraform
        cat > terraform.tfvars << EOF
        aws_region = "${{ env.AWS_REGION }}"
        project_name = "catalog-server"
        environment = "production"
        instance_type = "t3.micro"
        key_pair_name = "catalog-server-key"
        allowed_cidr_blocks = ["0.0.0.0/0"]
        db_username = "catalog_user"
        db_password = "${{ secrets.DB_PASSWORD }}"
        db_name = "catalogdb"
        EOF

    - name: Terraform Init
      run: |
        cd terraform
        terraform init

    - name: Terraform Plan
      run: |
        cd terraform
        terraform plan

    - name: Terraform Apply
      id: terraform
      run: |
        cd terraform
        terraform apply -auto-approve
        
        # Capture outputs
        echo "ec2_public_ip=$(terraform output -raw ec2_public_ip)" >> $GITHUB_OUTPUT
        echo "cognito_user_pool_id=$(terraform output -raw cognito_user_pool_id)" >> $GITHUB_OUTPUT
        echo "cognito_user_pool_client_id=$(terraform output -raw cognito_user_pool_client_id)" >> $GITHUB_OUTPUT
        echo "cognito_identity_pool_id=$(terraform output -raw cognito_identity_pool_id)" >> $GITHUB_OUTPUT
        echo "rds_endpoint=$(terraform output -raw rds_endpoint)" >> $GITHUB_OUTPUT

  # Test backend
  test-backend:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install Python dependencies
      run: |
        cd backend
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Test backend
      env:
        DATABASE_URL: postgresql://postgres:testpass@localhost:5432/testdb
        SECRET_KEY: test-secret-key
      run: |
        cd backend
        python -c "
        from app import app, db
        with app.app_context():
            db.create_all()
            print('Backend tests passed!')
        "

  # Build frontend
  build-frontend:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install frontend dependencies
      run: |
        cd frontend
        npm ci

    - name: Generate environment file
      run: |
        cd frontend
        cat > .env << EOF
        REACT_APP_USER_POOL_ID=${{ needs.deploy-infrastructure.outputs.cognito_user_pool_id }}
        REACT_APP_USER_POOL_CLIENT_ID=${{ needs.deploy-infrastructure.outputs.cognito_user_pool_client_id }}
        REACT_APP_IDENTITY_POOL_ID=${{ needs.deploy-infrastructure.outputs.cognito_identity_pool_id }}
        REACT_APP_API_URL=http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
        REACT_APP_AWS_REGION=${{ env.AWS_REGION }}
        EOF

    - name: Build frontend
      run: |
        cd frontend
        npm run build

    - name: Upload frontend build
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: frontend/build/

  # Deploy application
  deploy-application:
    needs: [deploy-infrastructure, test-backend, build-frontend]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download frontend build
      uses: actions/download-artifact@v4
      with:
        name: frontend-build
        path: frontend/build/

    - name: Generate backend environment file
      run: |
        cd backend
        cat > .env << EOF
        DATABASE_URL=postgresql://catalog_user:${{ secrets.DB_PASSWORD }}@${{ needs.deploy-infrastructure.outputs.rds_endpoint }}:5432/catalogdb
        SECRET_KEY=${{ secrets.FLASK_SECRET_KEY }}
        FLASK_ENV=production
        EOF

    - name: Deploy to EC2
      env:
        EC2_HOST: ${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
        EC2_USER: ubuntu
        EC2_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
      run: |
        # Create SSH key file
        echo "$EC2_KEY" > ec2-key.pem
        chmod 600 ec2-key.pem
        
        # Wait for EC2 to be ready and user-data script to complete
        echo "Waiting for EC2 instance and user-data script..."
        sleep 120
        
        # Wait for user-data script to complete by checking cloud-init status
        echo "Checking if user-data script completed..."
        timeout 300 ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          while ! sudo cloud-init status --wait; do
            echo 'Waiting for cloud-init to complete...'
            sleep 10
          done
          echo 'Cloud-init completed successfully'
        "
        
        # Ensure directory structure exists and has correct permissions
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          sudo mkdir -p /opt/catalog-server/backend
          sudo mkdir -p /opt/catalog-server/frontend
          sudo chown -R catalog:catalog /opt/catalog-server
          sudo chmod -R 755 /opt/catalog-server
        "
        
        # Deploy nginx config to tmp first (only if it exists)
        if [ -f nginx/catalog.conf ]; then
          echo "Deploying custom nginx config..."
          scp -i ec2-key.pem -o StrictHostKeyChecking=no nginx/catalog.conf $EC2_USER@$EC2_HOST:/tmp/
        else
          echo "No custom nginx config found, using default from user-data..."
        fi
        
        # Deploy backend files to tmp, then move with proper permissions
        echo "Deploying backend files..."
        scp -i ec2-key.pem -o StrictHostKeyChecking=no -r backend/* $EC2_USER@$EC2_HOST:/tmp/backend-files/
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          sudo cp -r /tmp/backend-files/* /opt/catalog-server/backend/
          sudo chown -R catalog:catalog /opt/catalog-server/backend
          sudo rm -rf /tmp/backend-files
          
          # Install additional dependencies from requirements.txt if it exists
          if [ -f /opt/catalog-server/backend/requirements.txt ]; then
            echo 'Installing additional Python dependencies...'
            cd /opt/catalog-server/backend
            sudo -u catalog /opt/catalog-server/backend/venv/bin/pip install -r requirements.txt
          fi
        "
        
        # Deploy frontend files
        echo "Deploying frontend files..."
        scp -i ec2-key.pem -o StrictHostKeyChecking=no -r frontend/build/* $EC2_USER@$EC2_HOST:/tmp/frontend-files/
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          sudo cp -r /tmp/frontend-files/* /opt/catalog-server/frontend/
          sudo chown -R catalog:catalog /opt/catalog-server/frontend
          sudo rm -rf /tmp/frontend-files
        "
        
        # Configure and restart services
        echo "Configuring services..."
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          # Only update nginx config if custom one was uploaded
          if [ -f /tmp/catalog.conf ]; then
            sudo cp /tmp/catalog.conf /etc/nginx/sites-available/catalog
            sudo ln -sf /etc/nginx/sites-available/catalog /etc/nginx/sites-enabled/
            sudo rm -f /etc/nginx/sites-enabled/default
          fi
          
          # Test nginx config before restarting
          sudo nginx -t
          if [ \$? -eq 0 ]; then
            echo 'Nginx config is valid'
          else
            echo 'Nginx config error, keeping default config'
            sudo rm -f /etc/nginx/sites-enabled/catalog
          fi
          
          # Start catalog service (it was enabled in user-data but not started)
          echo 'Starting catalog service...'
          sudo systemctl daemon-reload
          sudo systemctl start catalog
          sleep 5
          
          # Check if catalog service started successfully
          if sudo systemctl is-active --quiet catalog; then
            echo 'Catalog service started successfully'
          else
            echo 'Catalog service failed to start, checking logs:'
            sudo journalctl -u catalog --no-pager -n 20
            
            # Try to start it manually for debugging
            echo 'Trying to start Flask app manually:'
            cd /opt/catalog-server/backend
            sudo -u catalog /opt/catalog-server/backend/venv/bin/python app.py &
            sleep 3
          fi
          
          # Restart nginx
          sudo systemctl restart nginx
          sudo systemctl status catalog --no-pager
          sudo systemctl status nginx --no-pager
        "
        
        rm ec2-key.pem

    - name: Health check
      env:
        API_URL: http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
      run: |
        echo "Waiting for services to start..."
        sleep 30
        
        # Debug: Check if services are running
        echo "=== Debugging Services ==="
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no ubuntu@${{ needs.deploy-infrastructure.outputs.ec2_public_ip }} "
          echo 'Checking catalog service status:'
          sudo systemctl status catalog --no-pager || echo 'Catalog service not running'
          
          echo -e '\nChecking nginx status:'
          sudo systemctl status nginx --no-pager || echo 'Nginx service not running'
          
          echo -e '\nChecking if Flask app is responding locally:'
          curl -f http://localhost:5000/health || echo 'Flask app not responding'
          
          echo -e '\nChecking nginx error logs:'
          sudo tail -10 /var/log/nginx/error.log || echo 'No nginx error logs'
          
          echo -e '\nChecking catalog service logs:'
          sudo journalctl -u catalog --no-pager -n 10 || echo 'No catalog service logs'
          
          echo -e '\nChecking if port 5000 is listening:'
          sudo netstat -tlnp | grep :5000 || echo 'Port 5000 not listening'
        "
        
        # Try health check
        echo "=== Testing Health Check ==="
        curl -v $API_URL/health || {
          echo "Health check failed with direct curl"
          exit 1
        }
        
        curl -f $API_URL/products || {
          echo "Products endpoint failed"
          exit 1
        }
        
        echo "✅ Deployment successful!"
        echo "🌐 Application URL: $API_URL"

    - name: Deployment summary
      run: |
        echo "## 🚀 Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status | URL |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|-----|" >> $GITHUB_STEP_SUMMARY
        echo "| Application | ✅ Deployed | http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }} |" >> $GITHUB_STEP_SUMMARY
        echo "| API Health | ✅ Healthy | http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}/health |" >> $GITHUB_STEP_SUMMARY