name: Deploy Catalog Server with Automated Environment Setup

# Trigger deployment on push to main branch
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Environment variables
env:
  AWS_REGION: eu-west-1
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.10'
  TF_VAR_terraform_state_bucket: ${{ secrets.TERRAFORM_STATE_BUCKET }}

jobs:
  # Infrastructure deployment
  deploy-infrastructure:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    outputs:
      ec2_public_ip: ${{ steps.terraform.outputs.ec2_public_ip }}
      cognito_user_pool_id: ${{ steps.terraform.outputs.cognito_user_pool_id }}
      cognito_user_pool_client_id: ${{ steps.terraform.outputs.cognito_user_pool_client_id }}
      cognito_identity_pool_id: ${{ steps.terraform.outputs.cognito_identity_pool_id }}
      rds_endpoint: ${{ steps.terraform.outputs.rds_endpoint }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: Create Terraform variables file
      run: |
        cd terraform
        cat > terraform.tfvars << EOF
        aws_region = "${{ env.AWS_REGION }}"
        project_name = "catalog-server"
        environment = "production"
        instance_type = "t3.micro"
        key_pair_name = "catalog-server-key"
        allowed_cidr_blocks = ["0.0.0.0/0"]
        db_username = "catalog_user"
        db_password = "${{ secrets.DB_PASSWORD }}"
        db_name = "catalog"
        terraform_state_bucket = "${{ secrets.TERRAFORM_STATE_BUCKET }}"
        EOF

    - name: Terraform Init
      run: |
        cd terraform
        terraform init

    - name: Terraform Plan
      run: |
        cd terraform
        terraform plan

    - name: Terraform Apply
      id: terraform
      run: |
        cd terraform
        terraform apply -auto-approve
        
        # Capture outputs for use in other jobs
        echo "ec2_public_ip=$(terraform output -raw ec2_public_ip)" >> $GITHUB_OUTPUT
        echo "cognito_user_pool_id=$(terraform output -raw cognito_user_pool_id)" >> $GITHUB_OUTPUT
        echo "cognito_user_pool_client_id=$(terraform output -raw cognito_user_pool_client_id)" >> $GITHUB_OUTPUT
        echo "cognito_identity_pool_id=$(terraform output -raw cognito_identity_pool_id)" >> $GITHUB_OUTPUT
        echo "rds_endpoint=$(terraform output -raw rds_endpoint)" >> $GITHUB_OUTPUT

  # Test backend
  test-backend:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install Python dependencies
      run: |
        cd backend
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Test backend
      env:
        DATABASE_URL: postgresql://postgres:testpass@localhost:5432/testdb
        SECRET_KEY: test-secret-key
      run: |
        cd backend
        python -c "
        from app import app, db
        with app.app_context():
            db.create_all()
            print('Backend tests passed!')
        "

  # Build frontend with dynamic environment variables
  build-frontend:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install frontend dependencies
      run: |
        cd frontend
        npm ci

    - name: Generate environment file from Terraform outputs
      run: |
        cd frontend
        cat > .env << EOF
        REACT_APP_USER_POOL_ID=${{ needs.deploy-infrastructure.outputs.cognito_user_pool_id }}
        REACT_APP_USER_POOL_CLIENT_ID=${{ needs.deploy-infrastructure.outputs.cognito_user_pool_client_id }}
        REACT_APP_IDENTITY_POOL_ID=${{ needs.deploy-infrastructure.outputs.cognito_identity_pool_id }}
        REACT_APP_API_URL=http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
        REACT_APP_AWS_REGION=${{ env.AWS_REGION }}
        EOF
        
        echo "Generated frontend .env file:"
        cat .env

    - name: Build frontend
      run: |
        cd frontend
        npm run build

    - name: Upload frontend build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: frontend/build/

  # Deploy application
  deploy-application:
    needs: [deploy-infrastructure, test-backend, build-frontend]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download frontend build
      uses: actions/download-artifact@v4
      with:
        name: frontend-build
        path: frontend/build/

    - name: Generate backend environment file
      run: |
        cd backend
        cat > .env << EOF
        DATABASE_URL=postgresql://${{ secrets.DB_USERNAME }}:${{ secrets.DB_PASSWORD }}@${{ needs.deploy-infrastructure.outputs.rds_endpoint }}:5432/catalog
        SECRET_KEY=${{ secrets.FLASK_SECRET_KEY }}
        FLASK_ENV=production
        EOF
        
        echo "Generated backend .env file (secrets hidden)"

    - name: Deploy nginx configuration
      env:
        EC2_HOST: ${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
        EC2_USER: ubuntu
        EC2_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
      run: |
        # Create SSH key file
        echo "$EC2_KEY" > ec2-key.pem
        chmod 600 ec2-key.pem
        
        # Wait for EC2 to be ready
        echo "Waiting for EC2 instance to be ready..."
        sleep 60
        
        # Copy nginx configuration
        echo "Deploying nginx configuration..."
        scp -i ec2-key.pem -o StrictHostKeyChecking=no nginx/catalog.conf $EC2_USER@$EC2_HOST:/tmp/
        
        # Install nginx configuration
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          sudo cp /tmp/catalog.conf /etc/nginx/sites-available/catalog
          sudo ln -sf /etc/nginx/sites-available/catalog /etc/nginx/sites-enabled/
          sudo rm -f /etc/nginx/sites-enabled/default
          sudo nginx -t
        "

    - name: Deploy backend to EC2
      env:
        EC2_HOST: ${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
        EC2_USER: ubuntu
        EC2_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
      run: |
        # Copy backend files to EC2
        echo "Deploying backend files..."
        scp -i ec2-key.pem -o StrictHostKeyChecking=no -r backend/* $EC2_USER@$EC2_HOST:/opt/catalog-server/backend/
        
        # Restart backend service
        echo "Restarting backend service..."
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          sudo systemctl restart catalog
          sudo systemctl status catalog --no-pager
        "

    - name: Deploy frontend to EC2
      env:
        EC2_HOST: ${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
        EC2_USER: ubuntu
        EC2_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
      run: |
        # Create frontend directory structure on EC2 if it doesn't exist
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          sudo mkdir -p /opt/catalog-server/frontend
          sudo chown -R catalog:catalog /opt/catalog-server/frontend
        "
        
        # Copy frontend build to EC2
        echo "Deploying frontend files..."
        scp -i ec2-key.pem -o StrictHostKeyChecking=no -r frontend/build/* $EC2_USER@$EC2_HOST:/opt/catalog-server/frontend/
        
        # Restart nginx
        echo "Restarting nginx..."
        ssh -i ec2-key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
          sudo systemctl restart nginx
          sudo systemctl status nginx --no-pager
        "
        
        # Clean up SSH key
        rm ec2-key.pem

    - name: Health check and deployment verification
      env:
        API_URL: http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
      run: |
        # Wait for services to start
        echo "Waiting for services to start..."
        sleep 30
        
        # Check if API is responding
        echo "Testing API health..."
        curl -f $API_URL/health || exit 1
        
        # Test products endpoint
        echo "Testing products endpoint..."
        curl -f $API_URL/products || exit 1
        
        echo "âœ… Deployment successful!"
        echo "ðŸŒ Application URL: $API_URL"
        echo "ðŸ”— API Health: $API_URL/health"
        echo "ðŸ“¦ Products API: $API_URL/products"

    - name: Post deployment summary
      run: |
        echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status | URL |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|-----|" >> $GITHUB_STEP_SUMMARY
        echo "| Application | âœ… Deployed | http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }} |" >> $GITHUB_STEP_SUMMARY
        echo "| API Health | âœ… Healthy | http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}/health |" >> $GITHUB_STEP_SUMMARY
        echo "| Products API | âœ… Working | http://${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}/products |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
        echo "1. Visit the application URL to test user registration" >> $GITHUB_STEP_SUMMARY
        echo "2. Check AWS Cognito console for user management" >> $GITHUB_STEP_SUMMARY
        echo "3. Monitor CloudWatch logs for any issues" >> $GITHUB_STEP_SUMMARY